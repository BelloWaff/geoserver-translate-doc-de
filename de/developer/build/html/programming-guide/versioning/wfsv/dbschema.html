
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  
  <title>Datastore design &mdash; GeoServer 2.2.x Developer Manual</title>
  <link rel="stylesheet" href="../../../_static/blueprint/screen.css" type="text/css" media="screen, projection" />
  <link rel="stylesheet" href="../../../_static/blueprint/print.css" type="text/css" media="print" /> 
  <!--[if IE]>
  <link rel="stylesheet" href="../../../_static/blueprint/ie.css" type="text/css" media="screen, projection" />
  <![endif]-->
  <link rel="stylesheet" href="../../../_static/default.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <script type="text/javascript">
    var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '2.2.x',
        COLLAPSE_MODINDEX: false,
        FILE_SUFFIX: '.html'
    };
  </script>
  <script type="text/javascript" src="../../../_static/jquery.js"></script>
  <script type="text/javascript" src="../../../_static/doctools.js"></script>
  <script type="text/javascript" src="../../../_static/searchtools.js"></script>
  <script type="text/javascript" src="../../../searchindex.js"></script>
      <link rel="top" title="GeoServer 2.2.x Developer Manual" href="../../../index.html" />
      <link rel="up" title="Versioning implementation" href="implementation.html" />
      <link rel="next" title="Versioning WFS - GT2 Datastore extensions" href="gtstore-extensions.html" />
      <link rel="prev" title="Early implementation proposal" href="chris.html" />
</head>
<body class="programming-guide/versioning/wfsv/dbschema">
  <div id="header" class="selfclear">
    <div class="wrap selfclear">
      <div id="logo"><a href="../../../index.html">GeoServer 2.2.x Developer Manual</a></div>
      <ul id="top-nav">
        <li class="first"><a href="http://geoserver.org/display/GEOS/What+is+Geoserver">About</a></li>
        <li><a href="http://blog.geoserver.org/">Blog</a></li>
        <li><a href="http://geoserver.org/display/GEOS/Download">Download</a></li>
        <li><a href="../../../index.html">Documentation</a></li>
      </ul>
        <form id="quick-search" action="../../../search.html" method="get">
          <fieldset>
            <input type="hidden" name="check_keywords" value="yes" />
            <input type="hidden" name="area" value="default" />
            <input id="quick-search-query" type="text" name="q" accessKey="q" name="searchQuery.queryString" size="25" value="Search Documentation&hellip;" size="20" tabindex="3" onblur="if(this.value=='') this.value='Search Documentation&hellip;';" onfocus="if(this.value=='Search Documentation&hellip;') this.value='';" />
            <input id="quick-search-submit" type="image" value="Search" src="../../../_static/chrome/search_icon_green.png" />
          </fieldset>
        </form>
    </div><!-- /.wrap -->
  </div><!-- /#header -->
  <div id="main">
    <div class="wrap selfclear">
      <div id="content">
<ul id="breadcrumbs">
  
  <li><a href="../../../index.html">GeoServer 2.2.x Developer Manual</a> &raquo;</li>
  <li><a href="../../index.html" accesskey="U">Programming Guide</a> &raquo;</li>
  <li><a href="../index.html" accesskey="U">Versioning</a> &raquo;</li>
  <li><a href="implementation.html" accesskey="U">Versioning implementation</a> &raquo;</li>
  <li>Datastore design</li>
</ul>
<ul id="relatedlinks" class="selfclear">
  <li class="first">
    <a href="gtstore-extensions.html" title="Versioning WFS - GT2 Datastore extensions"
       accesskey="N">next</a></li>
  <li>
    <a href="chris.html" title="Early implementation proposal"
       accesskey="P">previous</a>|</li>
</ul>
        
  <div class="section" id="datastore-design">
<span id="versioning-implementation-dbschema"></span><h1>Datastore design<a class="headerlink" href="#datastore-design" title="Permalink to this headline">¶</a></h1>
<p>The solution is a mix between Oracle, ArcSDe, svn and the Chris proposal. From a classification point of view, it&#8217;s a forward only versioning with no diffs, and no branches, using progressive revision numbers like svn.</p>
<p>Here is the diagram:</p>
<p>The <strong>Data</strong> table represents a single versioned feature type, has all the attributes of the normal feature type, and a few extra columns:</p>
<ul class="simple">
<li>rowId: the primary key if the versioning was not there, backed by a sequence.</li>
<li>revisionCreated: the revision where the row was introduced (as a result of an insert or of a row update).</li>
<li>revisionExpired: the revision where the row was marked as &#8220;old&#8221; (as a result of a deletion or an update). For rows that are not expired, it&#8217;s assumed to be MAXLONG (because, as you&#8217;ll see, this eases querying).</li>
</ul>
<p>The Data table primary key is (rowId, revisionCreated). RevisionExpired should be indexed as well.</p>
<p>The <strong>ChangeSet</strong> represents the change in a set of rows contained in versioned feature type as a result of a Transaction or rollback operation. The columns are:</p>
<ul class="simple">
<li>revision: backed by a sequence, it&#8217;s the global revision number, backed by a sequence (primary key of this table).</li>
<li>author: is the id/name/whatever of the person/system that performed the change.</li>
<li>date: the full timestamp (milliseconds included) of the change.</li>
<li>bbox: the area that the changes involved, expressed in ESPG:4326 (since different feature types may be expressed in different CRS).</li>
<li>message: the commit message for the change.</li>
</ul>
<p>Each changeset is associated to a list of involved tables, in order to ease finding the changed records for each changeset.</p>
<p>The <strong>VersionedTable</strong> table is a list containing the currently versioned feature types:</p>
<ul class="simple">
<li>versionedTableId: backed by a sequence, it&#8217;s the primary key;</li>
<li>name: the versioned table name</li>
</ul>
<div class="section" id="common-operations-implementations-in-terms-of-sql-queries">
<h2>Common operations implementations in terms of SQL queries<a class="headerlink" href="#common-operations-implementations-in-terms-of-sql-queries" title="Permalink to this headline">¶</a></h2>
<p>It&#8217;s interesting to see how this design allows for relatively simple queries for the most common operations:</p>
<ul>
<li><p class="first">Gather a specific revision, with filter:</p>
<div class="highlight-python"><pre>select *
from data
where &lt;filter encoded in sql&gt;
and revisionCreated &lt;= [revision]
and revisionExpired &gt; [revision]</pre>
</div>
</li>
<li><p class="first">Last version, with filter:</p>
<div class="highlight-python"><pre>select max(revision)
from changes

and then the same as gathering a specific revision</pre>
</div>
</li>
<li><p class="first">State at a certain point in time:</p>
<div class="highlight-python"><pre>select max(revision)
from changes
where date &lt; [specifiedDate]

and then the same as getting a specific revision.</pre>
</div>
</li>
<li><p class="first">Rollback to a specific revision, but keeping history:
First a set of intersting queries in order to undersand what&#8217;s going on:
All modified rows between revision and current, and matching a certain filter at some point during the evolution of that branch:</p>
<div class="highlight-python"><pre>select distinct(rowId) from data
where revisionCreated  &gt; [revision]
and [filter]</pre>
</div>
<p>Original state of all rows existing at the specified revision (and matching the filter):</p>
<div class="highlight-python"><pre>select data1.*
from data data1
and data1.revisionCreated &lt;= [revision]
and data1.revisionExpired &gt; [revision]
and data1.rowId in (
  select data2.rowId
  from data data2
  where   data2.revisionCreated &gt; [revision]
  and [filter])</pre>
</div>
<p>Current state of all rows created and not deleted after the specified revision:</p>
<div class="highlight-python"><pre>select * from data
where revisionCreated &gt; [revision]
and revisionExpired = [maxLong]
and rowId not in (
 select rowId
 where data1.revisionExpired &gt; [revision]
 and [filter])</pre>
</div>
<p>So basically reverting means running the following queries:</p>
<div class="highlight-python"><pre>-- update old revisions, equates to a deletion
-- for those that were not there
update data
set revisionExpired = [newRevision]
from data
where revisionCreated &gt; [revision]
and revisionExpired = [maxLong]
and rowid in  (
   select rowId
   from data data2
   where data2.expired &gt; [revision]
   and [filter]
)

-- inserts the old values for all data that
-- has been updated or deleted between the two  revisions
insert into data
select d.* (besides rev numbers), [newRevision], [maxLong]
from data d
where d.revisionCreated &gt;= [revision]
and d.revisionExpired &gt; [revision]
and d.rowId in (
 select data2.rowId
 from data data2
 where data2.revisionExpired &gt; [revision]
 and [filter]
)</pre>
</div>
</li>
<li><p class="first">Diffing between revision n and revision m
Last value of everything changed between n and m (m &gt; n), and satisfying a filter in one of the past states (if row is not changed, it won&#8217;t have old states between n and m):</p>
<div class="highlight-python"><pre>select *
from data d1
where revisionCreated &lt;= m
and revisionExpired &gt;= m
and rowId in (
  select rowid
  from data d2
  where d2.rowid = d1.rowid
  and revisionCreated &lt; d1.revisionCreated
  and revisionExpired &gt; n
  and [filter])
order by rowId</pre>
</div>
<p>Value at n of everything changed between n and m (eventually deleted):</p>
<div class="highlight-python"><pre>select *
from data d1
where revisionCreated &lt;= n
and revisionExpired &gt; n
and rowId in (
  select rowid
  from data d2
  where d2.rowid = d1.rowid
  and revisionCreated &gt; d1.revisionCreated
  and [filter])
order by rowId</pre>
</div>
<p>Then the two sets must be scanned in parallel like in a merge sort and diffs must be generated (the diff format is still a matter of discussion). This unfortunately works fine only for single column keys, for multicolumns it&#8217;s not as obvious, especially if the primary key is allowed to change like in the multicolumn fid mappers. Hmmm... this must be forbidden in fact for identity chain to work (rowid is what keeps togheter the rows history...).</p>
<p>Moreover, the discussion assumes filter can be encoded in sql, and it may not be the case... this complicates matters a lot since the filter is to be applied in a subquery that does not return values.</p>
</li>
<li><p class="first">Getting change history for a table, with eventual filter on area or user:</p>
<div class="highlight-python"><pre>select date, author, revision, message
from ChangeSets
where revision in (
   select revision
   from TablesChanged
   where versionedTableId = [tableId])
and bbox &amp;&amp; [searchArea]
and user = [specifiedUser]</pre>
</div>
</li>
</ul>
</div>
<div class="section" id="performance-tests">
<h2>Performance tests<a class="headerlink" href="#performance-tests" title="Permalink to this headline">¶</a></h2>
<p>One of the main concerns given the data structures we are setting up is scalability, that is, we do expect a performance hit due to versioning, and wonder how severe it is compared to revision numbers in the database and the actual modifications performed by each release.</p>
<p>A good implementation should degrade no worse than O, where n is the total number of versioned records. Well, to my surprire, it seems the above table setup, with proper indexes, is less than linear, but almost constant .</p>
<p>To asses performance I&#8217;ve setup a little data filler and then a query benchmark.
The data filler:</p>
<ul class="simple">
<li>sets up a spatial table in Postgis with a linestring geometry, a text attribute, a numeric id and revision columns (testData table);</li>
<li>sets up a versioned spatial table with the same structure as the previous, but without the revision columns, as a reference of the performance that can be obtained without versioning around;</li>
<li>inserts a certain amount of data in testData as the first revision, filling the lat/lon space with a regular grid (each feature occupies a cell). Geometries are random, but guaranteed to fit in their cell.</li>
<li>starts versioning data modifiying for each revision a certain number of features, and marking as expired the current version of it;</li>
<li>fill the reference data table with a snapshot of the last revision;</li>
<li>does a vacuum analyze to make sure optimizer knows about data distribution.</li>
</ul>
<p>The query benchmark instead performs a few queries against reference and versioned data:</p>
<ul>
<li><p class="first">an extraction of the full data set from reference, and then last revision from versioned, and a few snapshots as specif versions;</p>
</li>
<li><dl class="first docutils">
<dt>an extraction of a bbox (big enough to be timed), and the same against the last revision and specific versions.</dt>
<dd><p class="first last">The above is run twice to make sure the are no caching effects around, and in fact, the second run does not seem to hit the disk at all, but runs against the file system cache.</p>
</dd>
</dl>
</li>
</ul>
<p>Tests have been performed on an Intel Core 2 Duo 2.13Ghz, 2GB RAM, and two 7200 rpm disks in RAID 0, Windows XP professional, Postgres 8.1.3 and Postgis 1.1.4 configured as &#8220;out of the box&#8221;, no extra tweaking on Postgres memory settings.</p>
<p>Here are the results with 100.000 reference features, and 4000 revisions modifying each 30 records (thus, 120.000 more records in the database), 220.000 records total:</p>
<div class="highlight-python"><pre>Reference data:

Running: select * from testDataRef
Elapsed: 1.157 s, returned records:100000

Running: select * from testData where expired = 9223372036854775807
Elapsed: 1.843 s, returned records:100000

Running: select * from testData where revision &lt;= 0 and expired &gt; 0
Elapsed: 1.704 s, returned records:100000

Running: select * from testData where revision &lt;= 2000 and expired &gt; 2000
Elapsed: 1.796 s, returned records:100000

Running: select * from testData where revision &lt;= 3999 and expired &gt; 3999
Elapsed: 1.844 s, returned records:100000

Running: select * from testDataRef where geom &amp;&amp; GeometryFromText('POLYGON((0 0, 80 0, 80 80, 0 80, 0 0))', 4326)
Elapsed: 0.125 s, returned records:9975

Running: select * from testData where expired = 9223372036854775807 and geom &amp;&amp; GeometryFromText('POLYGON((0 0, 80 0, 80 80, 0 80, 0 0))', 4326)
Elapsed: 0.203 s, returned records:9975

Running: select * from testData where revision &lt;= 3999 and expired &gt; 3999 and geom &amp;&amp; GeometryFromText('POLYGON((0 0, 80 0, 80 80, 0 80, 0 0))', 4326)
Elapsed: 0.235 s, returned records:9975</pre>
</div>
<p>And here are the results with 100.000 reference features, and 10000 revisions modifying each 30 records (thus, 300.000 more records in the database), 400.000 records total:</p>
<div class="highlight-python"><pre>Running: select * from testDataRef
Elapsed: 1.187 s, returned records:100000

Running: select * from testData where expired = 9223372036854775807
Elapsed: 1.875 s, returned records:100000

Running: select * from testData where revision &lt;= 0 and expired &gt; 0
Elapsed: 1.688 s, returned records:100000

Running: select * from testData where revision &lt;= 2000 and expired &gt; 2000
Elapsed: 1.765 s, returned records:100000

Running: select * from testData where revision &lt;= 9999 and expired &gt; 9999
Elapsed: 1.891 s, returned records:100000

Running: select * from testDataRef where geom &amp;&amp; GeometryFromText('POLYGON((0 0, 80 0, 80 80, 0 80, 0 0))', 4326)
Elapsed: 0.125 s, returned records:9981

Running: select * from testData where expired = 9223372036854775807 and geom &amp;&amp; GeometryFromText('POLYGON((0 0, 80 0, 80 80, 0 80, 0 0))', 4326)
Elapsed: 0.219 s, returned records:9981

Running: select * from testData where revision &lt;= 9999 and expired &gt; 9999 and geom &amp;&amp; GeometryFromText('POLYGON((0 0, 80 0, 80 80, 0 80, 0 0))', 4326)
Elapsed: 0.234 s, returned records:9981</pre>
</div>
<p>As you can see, despite the second run has to deal with twice the number of records in the versioned table, timings are the same.</p>
<p>You may wonder where is the magic. Well, the magic is good indexes and the Posgtres 8.0 onwards newly aquired ability to inspect multiple indexes during a single query, and do bitmap merging before accessing the actual data (this is used by the spatial queries). This is important, results won&#8217;t be</p>
<p>The table creation queries are here:</p>
<div class="highlight-python"><pre>create table testData (id bigint, txt varchar(256), revision bigint, expired bigint not null, primary key (revision, id))
select AddGeometryColumn('testdata', 'geom', 4326, 'LINESTRING', 2)
create index testDataGeomIdx on testData using gist (geom gist_geometry_ops)
create index testDataRevIdx on testData (expired, id)
create table testDataRef (id bigint, txt varchar(256), primary key (id))
select AddGeometryColumn('testdataref', 'geom', 4326, 'LINESTRING', 2)
create index testDataRefGeomIdx on testDataRef using gist (geom gist_geometry_ops)</pre>
</div>
<p>Observe the primary key order, which allows queries needing only revision to use the primary key as an index, and the other index, that allows the same for expired (id is there again to help queries that have to expire a certain record).</p>
<p>If you want to reproduce the test on your PC, the source of the benchmark is <a class="reference download internal" href="../../../_downloads/versioningPerf.zip"><tt class="xref download docutils literal"><span class="pre">attached</span></tt></a>.</p>
</div>
</div>


      <div class="selfclear pagination-nav">
          <div class="leftwise"><strong>Previous</strong>: <a href="chris.html" title="previous chapter">Early implementation proposal</a></div>
          <div class="rightwise"><strong>Next</strong>: <a href="gtstore-extensions.html" title="next chapter">Versioning WFS - GT2 Datastore extensions</a></div>
      </div>
      </div><!-- /#content> -->
  <div id="sidebar" class="contrast">
      <div id="toc" class="section">
        <h3 class="pngfix">Table Of Contents</h3>
        <ul>
<li><a class="reference internal" href="#">Datastore design</a><ul>
<li><a class="reference internal" href="#common-operations-implementations-in-terms-of-sql-queries">Common operations implementations in terms of SQL queries</a></li>
<li><a class="reference internal" href="#performance-tests">Performance tests</a></li>
</ul>
</li>
</ul>

        <div class="section-footer"></div>
      </div>
        <div class="section">
          <h3>Continue Reading</h3>
          <ul>
            <li>Previous: <a href="chris.html" title="previous chapter">Early implementation proposal</a></li>
            <li>Next: <a href="gtstore-extensions.html" title="next chapter">Versioning WFS - GT2 Datastore extensions</a></li>
          </ul>
        </div>
        <div class="section">
        <h3>This Page</h3>
        <ul class="this-page-menu">
          <li><a href="../../../_sources/programming-guide/versioning/wfsv/dbschema.txt">Show Source</a></li>
        </ul>
        </div>
  </div><!-- /#sidebar -->
  </div><!-- /.wrap> -->
</div><!-- /#main -->
<div id="footer">
  <div class="wrap">
    &copy; Copyright 2011 GeoServer.
    Last updated on Jan 04, 2013.
    Created using <a href="http://sphinx.pocoo.org/">Sphinx</a>.
  </div><!-- /.wrap> -->
</div><!-- /#footer -->
  </body>
</html>